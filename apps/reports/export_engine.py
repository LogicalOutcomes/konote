"""Template-driven report generation engine.

Orchestrates data collection and output formatting for template-driven
reports.  Delegates to generate_funder_report_data() for the heavy
lifting and applies suppression / formatting on top.

When the template has ReportMetric records with aggregation rules,
uses compute_template_metrics() for the metric-rows × demographic-columns
format specified in the DRR.  Falls back to legacy CSV format when no
ReportMetric records exist.

Separation from funder_report.py ensures the template pipeline cannot
accidentally fall back to flat ad-hoc output.

See tasks/design-rationale/reporting-architecture.md for the full spec.
"""
import csv
import io
import logging
from datetime import date, datetime, time

from django.utils import timezone
from django.utils.translation import gettext as _

from apps.clients.models import ClientProgramEnrolment
from apps.notes.models import ProgressNote

from .aggregation import compute_template_metrics
from .csv_utils import sanitise_csv_row, sanitise_filename
from .funder_report import (
    generate_funder_report_csv_rows,
    generate_funder_report_data,
    get_demographic_groups,
)
from .models import ReportMetric, ReportSection
from .suppression import SMALL_CELL_THRESHOLD, suppress_small_cell

logger = logging.getLogger(__name__)


def _get_active_client_ids(program, date_from, date_to, user=None):
    """Get IDs of clients with activity in the reporting period.

    Mirrors the logic in generate_funder_report_data() (lines 221–277)
    but returns just the IDs for use by get_demographic_groups().
    """
    from apps.clients.models import ClientFile
    from django.db.models import Q

    enrolled_client_ids = list(
        ClientProgramEnrolment.objects.filter(
            program=program, status="enrolled",
        ).values_list("client_file_id", flat=True)
    )

    if user is not None:
        if user.is_demo:
            accessible_ids = set(
                ClientFile.objects.demo().values_list("pk", flat=True)
            )
        else:
            accessible_ids = set(
                ClientFile.objects.real().values_list("pk", flat=True)
            )
        enrolled_client_ids = [
            cid for cid in enrolled_client_ids if cid in accessible_ids
        ]

    date_from_dt = timezone.make_aware(datetime.combine(date_from, time.min))
    date_to_dt = timezone.make_aware(datetime.combine(date_to, time.max))

    active_client_ids = list(
        ProgressNote.objects.filter(
            client_file_id__in=enrolled_client_ids,
            status="default",
        ).filter(
            Q(backdate__range=(date_from_dt, date_to_dt))
            | Q(backdate__isnull=True, created_at__range=(date_from_dt, date_to_dt))
        ).values_list("client_file_id", flat=True).distinct()
    )
    return active_client_ids


def generate_template_csv_rows(
    template,
    report_data,
    metric_results,
    demographic_labels,
    period_label,
    user,
):
    """Produce CSV rows in the DRR-specified metric-rows × demographic-columns format.

    Output format (from reporting-architecture.md):
        Report: United Way Quarterly Outcome Report
        Program: Youth Employment Services
        Period: Q3 FY2025-26 (Oct 1 – Dec 31, 2025)
        Generated: 2026-02-21
        Generated by: Kwame Asante (Executive Director)
        Template: United Way Quarterly v2.1

        Metric,All Participants,Age 13-17,Age 18-24,Age 25+
        Youth Engagement Index (mean),3.8,3.2,4.1,3.9
        Youth Engagement Index (n),50,12,28,10
        Goal Achievement Rate (%),64%,50%,71%,60%

    Args:
        template: ReportTemplate instance.
        report_data: Dict from generate_funder_report_data() (for metadata).
        metric_results: List from compute_template_metrics().
        demographic_labels: Ordered list of demographic group labels (column headers).
        period_label: Human-readable period string.
        user: Requesting user (for "generated by" line).

    Returns:
        List of lists (CSV rows).
    """
    rows = []

    # Metadata header
    rows.append([f"Report: {template.partner.translated_name} — {template.name}"])
    rows.append([f"Program: {report_data.get('program_name', '')}"])
    rows.append([f"Period: {period_label}"])

    generated_at = report_data.get("generated_at", timezone.now())
    if hasattr(generated_at, "strftime"):
        rows.append([f"Generated: {generated_at.strftime('%Y-%m-%d')}"])
    else:
        rows.append([f"Generated: {generated_at}"])

    display_name = getattr(user, "display_name", str(user)) if user else ""
    rows.append([f"Generated by: {display_name}"])
    rows.append([f"Template: {template.name}"])
    rows.append([])  # blank separator

    # Service statistics
    rows.append([_("Service Statistics")])
    rows.append([
        _("Total Individuals Served"),
        report_data.get("total_individuals_served", 0),
    ])
    rows.append([
        _("New Participants This Period"),
        report_data.get("new_clients_this_period", 0),
    ])
    rows.append([
        _("Total Service Contacts"),
        report_data.get("total_contacts", 0),
    ])
    rows.append([])

    # Metric table: metric-rows × demographic-columns
    if metric_results:
        header = [_("Metric")] + demographic_labels
        rows.append(header)

        for mr in metric_results:
            label = mr["label"]
            suffix = ""
            # Use the label_suffix from the first demographic group for display
            for group_label in demographic_labels:
                group_data = mr["values"].get(group_label, {})
                if group_data.get("label_suffix"):
                    suffix = f" {group_data['label_suffix']}"
                    break

            row = [f"{label}{suffix}"]
            for group_label in demographic_labels:
                group_data = mr["values"].get(group_label, {})
                value = group_data.get("value", "")
                n = group_data.get("n", 0)
                # Apply suppression using the canonical threshold
                if isinstance(n, int) and 0 < n < SMALL_CELL_THRESHOLD:
                    row.append(f"< {SMALL_CELL_THRESHOLD}")
                elif mr["aggregation"] in ("threshold_percentage", "percentage"):
                    row.append(f"{value}%")
                else:
                    row.append(value)
            rows.append(row)

            # Add count row (n) for aggregation types that have a meaningful n
            if mr["aggregation"] in ("average", "threshold_percentage", "percentage"):
                n_row = [f"{label} (n)"]
                for group_label in demographic_labels:
                    group_data = mr["values"].get(group_label, {})
                    n = group_data.get("n", 0)
                    if isinstance(n, int) and 0 < n < SMALL_CELL_THRESHOLD:
                        n_row.append(f"< {SMALL_CELL_THRESHOLD}")
                    else:
                        n_row.append(n)
                rows.append(n_row)

    return rows


def generate_template_report(template, date_from, date_to, period_label,
                             user, export_format, request):
    """
    Generate a template-driven report.

    Args:
        template: ReportTemplate instance (defines programs, metrics,
                  demographics, aggregation rules via Partner).
        date_from: Start of reporting period (date).
        date_to: End of reporting period (date).
        period_label: Human-readable period (e.g. "Q3 FY2025-26").
        user: Requesting user (for demo/real client filtering).
        export_format: "csv" or "pdf".
        request: HttpRequest (needed by PDF renderer).

    Returns:
        Tuple of (content, filename, client_count):
        - content: str (CSV) or bytes (PDF)
        - filename: suggested download filename
        - client_count: raw integer count for SecureExportLink
    """
    programs = list(template.partner.get_programs())
    total_client_count = 0

    # Check if this template has ReportMetric records with aggregation rules
    report_metrics = list(
        ReportMetric.objects.filter(
            report_template=template,
        ).select_related("metric_definition").order_by("sort_order")
    )
    has_aggregation = bool(report_metrics)

    # Generate data per program
    all_report_data = []
    all_metric_results = []
    all_demographic_labels = []

    for program in programs:
        report_data = generate_funder_report_data(
            program,
            date_from=date_from,
            date_to=date_to,
            fiscal_year_label=period_label,
            user=user,
            report_template=template,
        )

        raw_count = report_data.get("total_individuals_served", 0)
        if isinstance(raw_count, int):
            total_client_count += raw_count

        # Apply small-cell suppression
        report_data["total_individuals_served"] = suppress_small_cell(
            report_data["total_individuals_served"], program,
        )
        report_data["new_clients_this_period"] = suppress_small_cell(
            report_data["new_clients_this_period"], program,
        )
        if program.is_confidential and "age_demographics" in report_data:
            for age_group, count in report_data["age_demographics"].items():
                if isinstance(count, int):
                    report_data["age_demographics"][age_group] = suppress_small_cell(
                        count, program
                    )
        if program.is_confidential and "custom_demographic_sections" in report_data:
            for section in report_data["custom_demographic_sections"]:
                any_suppressed = False
                for cat_label, count in section["data"].items():
                    if isinstance(count, int):
                        suppressed = suppress_small_cell(count, program)
                        if suppressed != count:
                            any_suppressed = True
                        section["data"][cat_label] = suppressed
                if any_suppressed:
                    section["total"] = "suppressed"

        all_report_data.append((program, report_data))

        # Compute aggregated metrics per demographic group
        if has_aggregation:
            active_ids = _get_active_client_ids(program, date_from, date_to, user)
            demo_groups = get_demographic_groups(active_ids, date_to, template)
            metric_results = compute_template_metrics(
                program, date_from, date_to,
                report_metrics, demo_groups, user,
            )
            all_metric_results.append(metric_results)
            # Preserve demographic label order from the first program
            if not all_demographic_labels:
                all_demographic_labels = list(demo_groups.keys())

    # Use the first program's data for now (multi-program merge is future work)
    if len(programs) > 1:
        logger.warning(
            "Template %r spans %d programs but only %r is included in report. "
            "Multi-program aggregation is not yet implemented.",
            template.name, len(programs), programs[0].name,
        )
    _program, report_data = all_report_data[0]
    metric_results = all_metric_results[0] if all_metric_results else []

    safe_partner = sanitise_filename(template.partner.name.replace(" ", "_"))
    safe_period = sanitise_filename(period_label.replace(" ", "_"))

    # Query ReportSection for PDF structuring (step 7)
    sections = list(
        ReportSection.objects.filter(
            report_template=template,
        ).order_by("sort_order")
    )

    if export_format == "pdf":
        from .pdf_views import generate_funder_report_pdf
        pdf_response = generate_funder_report_pdf(
            request, report_data,
            sections=sections if sections else None,
            metric_results=metric_results if metric_results else None,
        )
        filename = f"Report_{safe_partner}_{safe_period}.pdf"
        content = pdf_response.content
    else:
        csv_buffer = io.StringIO()
        writer = csv.writer(csv_buffer)

        if has_aggregation and metric_results:
            # Use DRR-specified metric-rows × demographic-columns format
            csv_rows = generate_template_csv_rows(
                template, report_data, metric_results,
                all_demographic_labels, period_label, user,
            )
        else:
            # Fall back to legacy format when no ReportMetric records
            csv_rows = generate_funder_report_csv_rows(report_data)

        for row in csv_rows:
            writer.writerow(sanitise_csv_row(row))
        filename = f"Report_{safe_partner}_{safe_period}.csv"
        content = csv_buffer.getvalue()

    return content, filename, total_client_count
